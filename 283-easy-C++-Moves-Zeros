Moves Zeros
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Example:

Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/move-zeroes
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#my answer
#双指针
时间复杂度：O(n)。空间复杂度：O(1)，只使用常量空间。
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int s=0;
        while(s<nums.size()&&nums[s]) ++s;
        int f=s+1;
        while(f<nums.size()&&nums[f]==0) ++f;
        while(f<nums.size())
        {
            nums[s]=nums[f];
            nums[f]=0;
            ++s;
            while(f<nums.size()&&nums[f]==0) ++f;
        }
        return;
    }
};
执行用时 :16 ms, 在所有 C++ 提交中击败了94.95%的用户
内存消耗 :9.3 MB, 在所有 C++ 提交中击败了89.42%的用户

更简单的写法
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode/
void moveZeroes(vector<int>& nums) {
    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {
        if (nums[cur] != 0) {
            swap(nums[lastNonZeroFoundAt++], nums[cur]);
        }
    }
}

#solutions
双指针方法2 - 时间复杂度更慢一点儿
链接：https://leetcode-cn.com/problems/move-zeroes/solution/yi-dong-ling-by-leetcode/
void moveZeroes(vector<int>& nums) {
    int lastNonZeroFoundAt = 0;
    // If the current element is not 0, then we need to
    // append it just in front of last non 0 element we found. 
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[lastNonZeroFoundAt++] = nums[i];
        }
    }
    // After we have finished processing new elements,
    // all the non-zero elements are already at beginning of array.
    // We just need to fill remaining array with 0's.
    for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {
        nums[i] = 0;
    }
}
时间复杂度：O(n)。但是，操作仍然是局部优化的。代码执行的总操作（数组写入）为 n（元素总数）。
空间复杂度：O(1)，只使用常量空间。
