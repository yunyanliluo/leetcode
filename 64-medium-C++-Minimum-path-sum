Minimum path sum
最小路径和
给m*n网格（非负），找出左上角至右下角的最短路径和。要求只能向下或向右走一步。

#solutions

方法一.
#dp - 二维动态规划
#时间复杂度O（m*n），空间复杂度O（m*n）
由于只能向下或向右移动，因此每一个格子的上一步应是左边格子右移或者上边格子下移，需要取最短。注意边界情况，最上边一行和最左边一行的格子，只能由左边或上边移动得到。
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size(), n=grid[0].size();
        int dp[m][n];
        for (int i=0; i<m; ++i)
        for (int j=0; j<n; ++j)
        {
            if (i==0&&j==0) dp[i][j]=grid[i][j];
            else if (i==0&&j!=0) dp[i][j]=dp[i][j-1]+grid[i][j];
            else if (i!=0&&j==0) dp[i][j]=dp[i-1][j]+grid[i][j];
            else dp[i][j]=min(dp[i][j-1]+grid[i][j], dp[i-1][j]+grid[i][j]);
        }
        return dp[m-1][n-1];
    }
};
执行用时 :12 ms, 在所有 C++ 提交中击败了77.12%的用户
内存消耗 :10.6 MB, 在所有 C++ 提交中击败了90.13%的用户

也可以倒着来：
链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/
dp(i,j) 表示从坐标 (i, j) 到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，
对于每个元素考虑移动到右边或者下面，因此获得最小路径和。
我们有如下递推公式：dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))。注意边界情况。
#java code
public class Solution {
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        for (int i = grid.length - 1; i >= 0; i--) {
            for (int j = grid[0].length - 1; j >= 0; j--) {
                if(i == grid.length - 1 && j != grid[0].length - 1)
                    dp[i][j] = grid[i][j] +  dp[i][j + 1];
                else if(j == grid[0].length - 1 && i != grid.length - 1)
                    dp[i][j] = grid[i][j] + dp[i + 1][j];
                else if(j != grid[0].length - 1 && i != grid.length - 1)
                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);
                else
                    dp[i][j] = grid[i][j];
            }
        }
        return dp[0][0];
    }
}

方法二.
#dp - 一维动态规划
#时间复杂度O（m*n），空间复杂度O（n）
链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/
在上个解法中，我们可以用一个一维数组来代替二维数组，dp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。
首先初始化 dp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j) 为：dp(j)=grid(i,j)+min(dp(j),dp(j+1))
我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0) 就是最后的结果。
#java code
public class Solution {
   public int minPathSum(int[][] grid) {
       int[] dp = new int[grid[0].length];
       for (int i = grid.length - 1; i >= 0; i--) {
           for (int j = grid[0].length - 1; j >= 0; j--) {
               if(i == grid.length - 1 && j != grid[0].length - 1)
                   dp[j] = grid[i][j] +  dp[j + 1];
               else if(j == grid[0].length - 1 && i != grid.length - 1)
                   dp[j] = grid[i][j] + dp[j];
               else if(j != grid[0].length - 1 && i != grid.length - 1)
                   dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);
               else
                   dp[j] = grid[i][j];
           }
       }
       return dp[0];
   }
}

方法三.
#dp - 不需要额外存储空间
#时间复杂度O（m*n），空间复杂度O（1）
链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode/
和方法二相同，惟一的区别是，在原数组上存储，这样就不需要额外的存储空间。
#java code
public class Solution {
    public int minPathSum(int[][] grid) {
        for (int i = grid.length - 1; i >= 0; i--) {
            for (int j = grid[0].length - 1; j >= 0; j--) {
                if(i == grid.length - 1 && j != grid[0].length - 1)
                    grid[i][j] = grid[i][j] +  grid[i][j + 1];
                else if(j == grid[0].length - 1 && i != grid.length - 1)
                    grid[i][j] = grid[i][j] + grid[i + 1][j];
                else if(j != grid[0].length - 1 && i != grid.length - 1)
                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);
            }
        }
        return grid[0][0];
    }
}
#C++ code
链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/c-dong-tai-gui-hua-4mschao-guo-99-by-lunatic-kalei/
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();
        if(n==0)
            return 0;
        int m = grid[0].size();
        if(m==0)
            return 0;
        for(int i=1;i<m;i++)
        {
            grid[0][i] += grid[0][i-1];

        }
        for(int i=1;i<n;i++)
        {
            grid[i][0] += grid[i-1][0];
        }
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
            {
                grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[n-1][m-1];
    }
};
