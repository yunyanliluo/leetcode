回溯法

“回溯搜索”算法即“深度优先遍历 + 状态重置 + 剪枝”
1、“深度优先遍历” 就是“不撞南墙不回头”；
2、回头的时候要“状态重置”，即回到上一次来到的那个地方，“状态”要和上一次来的时候一样。在代码上，往往是在执行下一层递归的前后，代码的形式是“对称的”。
链接：https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/


回溯法实际上是一个类似于枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已经不满足求解条件时，就“回溯”返回，尝试别的路径。
当探索到某一步时，发现原先选择并不是最优或达不到目标，就回退一步重新选择，这种走不通就退回再走的技术称为“回溯法”。
树和图的DFS从某种意义上说就是回溯法。
递归回溯就是一种遍历的方式。

典型例题
LeetCode40.组合总和II：给定一个可以有重复元素的数组，每一个元素在同一个组合之中只能使用一次 e.g.[2,5,2,1,2],target=5,解集[[1,2,2],[5]]
LeetCode39.组合总和：给定一个无重复元素的数组，每一个元素可以在同一个组合之中被重复使用 e.g. [2,3,6,7],target=7,解集[[7],[2,2,3]]
研一入学考试：给定一个无重复元素的数组，每一个元素在同一个组合之中只能使用一次  e.g. [2,3,6,7],target=7,解集[[7]]

解法类似：均使用回溯法解决
研一题和39题很像，区别只在于回溯时候的pos取i+1（不允许重复）还是取i（允许重复）；
第40题和研一题的处理很像，只需增加判断解集中的解的去重，可以有两种方式：
   1.使用额外空间： 使用set，额外空间为解集的大小
   2.使用额外时间： 判断当前元素加入当前解是否会造成重复（方法见my answer的剪枝2）

另外78题子集也可以看一下，子集题还有位运算和动态规划两种解法。
